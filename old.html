<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2-DOF 평면 로봇팔 시뮬레이터</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #f7f7f7;
      }
      #p5-canvas {
        border: 2px solid #333;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        background-color: #ffffff;
        /* 캔버스가 부모 요소에 의해 크기 제어되도록 설정 */
        width: 100%;
        height: 100%;
      }
      .control-label {
        width: 120px;
        font-weight: 600;
      }
    </style>
  </head>
  <body class="p-6 h-screen flex flex-col lg:flex-row gap-6">
    <!-- Control Panel -->
    <div
      id="control-panel"
      class="lg:w-1/3 p-6 bg-white rounded-xl shadow-lg flex flex-col gap-4 max-h-full overflow-y-auto"
    >
      <h1 class="text-2xl font-bold text-gray-800 border-b pb-2 mb-2">
        로봇팔 제어판 (2-DOF)
      </h1>

      <div class="text-sm text-gray-600 mb-2">
        로봇팔은 X-Y 평면에서 움직이며, Z축(높이)은 고정됩니다. J1(어깨)는
        0~150°, J2(팔꿈치)는 -10~100° 범위로 제한됩니다.
      </div>

      <!-- Joint 1 (Shoulder) Control -->
      <div class="flex flex-col gap-2 p-3 bg-indigo-50 rounded-lg">
        <h2 class="font-semibold text-indigo-700">
          Joint 1 (어깨) - Upper Arm
        </h2>
        <div class="flex items-center">
          <span class="control-label text-xs">목표 각도 (0~150°):</span>
          <input
            type="range"
            id="targetAngle1_slider"
            min="0"
            max="150"
            value="45"
            step="1"
            class="w-full h-2 bg-indigo-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
        <div class="flex items-center">
          <span class="control-label text-xs">현재:</span>
          <span
            id="currentAngle1_display"
            class="font-mono text-sm ml-2 w-10 text-right"
            >0</span
          >°
          <span class="ml-4 control-label text-xs">목표:</span>
          <input
            type="number"
            id="targetAngle1_input"
            min="0"
            max="150"
            value="45"
            step="1"
            class="w-16 p-1 border rounded text-sm text-right font-mono focus:ring-indigo-500 focus:border-indigo-500"
          />°
        </div>
      </div>

      <!-- Joint 2 (Elbow) Control -->
      <div class="flex flex-col gap-2 p-3 bg-red-50 rounded-lg">
        <h2 class="font-semibold text-red-700">Joint 2 (팔꿈치) - Fore Arm</h2>
        <div class="flex items-center">
          <span class="control-label text-xs">목표 각도 (-10~100°):</span>
          <input
            type="range"
            id="targetAngle2_slider"
            min="-10"
            max="100"
            value="45"
            step="1"
            class="w-full h-2 bg-red-200 rounded-lg appearance-none cursor-pointer"
          />
        </div>
        <div class="flex items-center">
          <span class="control-label text-xs">현재:</span>
          <span
            id="currentAngle2_display"
            class="font-mono text-sm ml-2 w-10 text-right"
            >0</span
          >°
          <span class="ml-4 control-label text-xs">목표:</span>
          <input
            type="number"
            id="targetAngle2_input"
            min="-10"
            max="100"
            value="45"
            step="1"
            class="w-16 p-1 border rounded text-sm text-right font-mono focus:ring-red-500 focus:border-red-500"
          />°
        </div>
      </div>

      <!-- Pen Control -->
      <div class="flex flex-col gap-2 p-3 bg-yellow-100 rounded-lg">
        <h2 class="font-semibold text-yellow-800">펜 궤적 제어</h2>
        <div class="flex items-center justify-between">
          <label
            for="pen_toggle"
            class="control-label text-xs cursor-pointer flex-grow"
          >
            <span id="pen_status" class="font-bold text-gray-700"
              >펜 꺼짐 (OFF)</span
            >
          </label>
          <input
            type="checkbox"
            id="pen_toggle"
            class="form-checkbox h-5 w-5 text-yellow-500 rounded focus:ring-yellow-500 transition duration-150 ease-in-out"
          />
        </div>
        <button
          id="clear_path_button"
          class="mt-2 w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 shadow-md hover:shadow-lg"
        >
          궤적 지우기
        </button>
      </div>

      <!-- Speed Control -->
      <div class="flex flex-col gap-2 p-3 bg-gray-100 rounded-lg">
        <h2 class="font-semibold text-gray-700">시뮬레이션 속도</h2>
        <div class="flex items-center">
          <span class="control-label text-xs">이동 속도:</span>
          <input
            type="range"
            id="angleSpeed_slider"
            min="1"
            max="100"
            value="40"
            step="1"
            class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer"
          />
          <span
            id="angleSpeed_display"
            class="font-mono text-sm ml-2 w-10 text-right"
            >40</span
          >
        </div>
      </div>

      <!-- Zoom Control -->
      <div class="flex flex-col gap-2 p-3 bg-teal-50 rounded-lg">
        <h2 class="font-semibold text-teal-700">시뮬레이션 확대/축소</h2>
        <div class="flex items-center">
          <span class="control-label text-xs">배율 (0.5x ~ 2.0x):</span>
          <input
            type="range"
            id="zoom_slider"
            min="25"
            max="100"
            value="100"
            step="10"
            class="w-full h-2 bg-teal-200 rounded-lg appearance-none cursor-pointer"
          />
          <span id="zoom_display" class="font-mono text-sm ml-2 w-10 text-right"
            >1.0x</span
          >
        </div>
      </div>

      <!-- End-Effector Position Display -->
      <div class="p-3 bg-yellow-50 rounded-lg mt-4">
        <h2 class="font-semibold text-yellow-800">펜 끝 (End-Effector) 좌표</h2>
        <div class="font-mono text-sm mt-1">
          <p>X: <span id="x_end_display">0.00</span></p>
          <p>Y: <span id="y_end_display">0.00</span></p>
        </div>
      </div>
    </div>

    <!-- P5 Canvas -->
    <div class="lg:w-2/3 flex items-center justify-center min-h-[400px]">
      <div id="p5-canvas" class="w-full h-full min-h-[400px]"></div>
    </div>

    <!-- <script>
      // 로봇 제어 로직을 담는 Raccoon 클래스
      class Raccoon {
        #minEncoderJoint1 = 0; // 어깨(Upper Arm) 최소 각도 (0도)
        #maxEncoderJoint1 = 150; // 어깨(Upper Arm) 최대 각도 (150도)
        #minEncoderJoint2 = -10; // 팔꿈치(Fore Arm) 최소 각도 (-10도)
        #maxEncoderJoint2 = 100; // 팔꿈치(Fore Arm) 최대 각도 (100도)
        #angleSpeedOffset = 10;
        #intervalId = null;

        constructor(initialSpeed = 40) {
          // 시뮬레이션된 현재 각도 (degrees)
          this.encoderJoint1 = this.#minEncoderJoint1;
          this.encoderJoint2 = this.#minEncoderJoint2;

          // 목표 각도 (degrees)
          this.targetAngleJoint1 = 45; // 초기 시작 각도
          this.targetAngleJoint2 = 45; // 초기 시작 각도

          // 이동 속도 (degree/interval)
          this.angleSpeed = initialSpeed;

          // 시뮬레이션 시작
          this.startSimulation();
        }

        // 속도를 설정하고 내부적으로 보정
        set angleSpeed(value) {
          // value는 1~100 사이의 슬라이더 값. 실제 속도는 10으로 나눔.
          this._angleSpeed = value / this.#angleSpeedOffset;
        }

        get angleSpeed() {
          return this._angleSpeed;
        }

        // 각도 제한 적용 및 이동 시작
        moveByAngle(targetAngleJoint1, targetAngleJoint2) {
          // 어깨 각도 제한 (0도 ~ 150도)
          if (targetAngleJoint1 < this.#minEncoderJoint1)
            targetAngleJoint1 = this.#minEncoderJoint1;
          if (targetAngleJoint1 > this.#maxEncoderJoint1)
            targetAngleJoint1 = this.#maxEncoderJoint1;

          // 팔꿈치 각도 제한 (-10도 ~ 100도)
          if (targetAngleJoint2 < this.#minEncoderJoint2)
            targetAngleJoint2 = this.#minEncoderJoint2;
          if (targetAngleJoint2 > this.#maxEncoderJoint2)
            targetAngleJoint2 = this.#maxEncoderJoint2;

          this.targetAngleJoint1 = targetAngleJoint1;
          this.targetAngleJoint2 = targetAngleJoint2;
        }

        // 시뮬레이션 반복 로직
        updateSimulation() {
          let moved = false;

          // Joint 1 (어깨) 업데이트
          if (
            Math.abs(this.encoderJoint1 - this.targetAngleJoint1) >
            this.angleSpeed
          ) {
            if (this.encoderJoint1 < this.targetAngleJoint1) {
              this.encoderJoint1 += this.angleSpeed;
            } else {
              this.encoderJoint1 -= this.angleSpeed;
            }
            moved = true;
          } else if (this.encoderJoint1 !== this.targetAngleJoint1) {
            this.encoderJoint1 = this.targetAngleJoint1;
            moved = true;
          }

          // Joint 2 (팔꿈치) 업데이트
          if (
            Math.abs(this.encoderJoint2 - this.targetAngleJoint2) >
            this.angleSpeed
          ) {
            if (this.encoderJoint2 < this.targetAngleJoint2) {
              this.encoderJoint2 += this.angleSpeed;
            } else {
              this.encoderJoint2 -= this.angleSpeed;
            }
            moved = true;
          } else if (this.encoderJoint2 !== this.targetAngleJoint2) {
            this.encoderJoint2 = this.targetAngleJoint2;
            moved = true;
          }

          // UI 업데이트 (P5.js의 pdraw에서 이 값을 사용하여 그림을 그림)
          document.getElementById("currentAngle1_display").textContent =
            this.encoderJoint1.toFixed(1);
          document.getElementById("currentAngle2_display").textContent =
            this.encoderJoint2.toFixed(1);
        }

        startSimulation() {
          if (this.#intervalId === null) {
            // 50ms마다 각도 업데이트 시도
            this.#intervalId = setInterval(() => this.updateSimulation(), 50);
          }
        }

        stopSimulation() {
          if (this.#intervalId !== null) {
            clearInterval(this.#intervalId);
            this.#intervalId = null;
          }
        }
      }

      // Raccoon 인스턴스 초기화 (초기 속도 40)
      const raccoon = new Raccoon(40);

      // P5.js 스케치 변수
      let canvasWidth, canvasHeight;

      // --- 로봇팔 치수 설정 ---
      /**
       * 상박(Upper Arm)의 실제 길이 (L1) (픽셀 단위). 실제 제원에 맞게 조정하세요.
       * 예: 388mm = 388 픽셀로 간주
       */
      let link1Wheelbase = 388;

      /**
       * 하박(Fore Arm)의 실제 길이 (L2) (픽셀 단위). 실제 제원에 맞게 조정하세요.
       */
      let link2Wheelbase = 388;

      /** 팔 링크의 시각적인 두께 */
      const linkWidth = 30;

      // 몸통(Body)의 치수 설정
      /** 몸통부 너비 (X축 방향) */
      const bodyWidth = 250;
      /** 몸통부 높이 (Y축 방향) */
      const bodyHeight = 150;
      // -------------------------

      let canvasScale = 1.0; // 확대/축소 배율
      let isPenDown = false; // 펜 궤적 그리기 상태
      let pathPoints = []; // 펜 궤적 좌표를 저장하는 배열 (어깨 기준 상대 좌표)

      // 로봇팔의 기준점 (어깨, Joint 1의 중심)
      let shoulderX, shoulderY;

      // 이미지 애셋 변수 선언 (로컬 환경에서 이미지를 로드할 때 사용)
      let topAsset, upperArmAsset, foreArmAsset;

      // P5.js 스케치 정의
      let p5sketch = new p5((p) => {
        p.setup = function () {
          // 캔버스 크기를 컨테이너에 맞춤
          const container = document.getElementById("p5-canvas");
          canvasWidth = container.clientWidth;
          canvasHeight = container.clientHeight;
          p.createCanvas(canvasWidth, canvasHeight);

          // ***********************************************
          // ** 로봇팔 기준점 (어깨) 위치를 오른쪽 아래로 조정 (X축 55%로 중앙화) **
          // ***********************************************
          shoulderX = canvasWidth * 1.5; // X축 55% 지점 (중앙으로 이동)
          shoulderY = canvasHeight * 1.5; // Y축 80% 지점 (아래쪽으로 이동)
        };

        p.draw = () => {
          p.background(250);

          // 로봇팔 현재 각도를 가져옴 (Raccoon 클래스에서 시뮬레이션된 값)
          const J1_angle_deg = raccoon.encoderJoint1;
          const J2_angle_deg = raccoon.encoderJoint2;

          const J1_rad = p.radians(J1_angle_deg);
          const J2_rad = p.radians(J2_angle_deg);

          // --- 1. 확대/축소 적용 (Draw Everything) ---
          p.push();
          p.scale(canvasScale);

          // --- 1. 몸통 (Body) 그리기 ---
          p.fill(50, 50, 100); // 짙은 파란색 몸통
          p.noStroke();
          p.rectMode(p.CENTER);
          // 몸통의 우측 상단 모서리가 어깨 관절 위치(shoulderX, shoulderY)가 되도록 배치
          p.rect(
            shoulderX - bodyWidth * 0.5,
            shoulderY + bodyHeight * 0.5,
            bodyWidth,
            bodyHeight,
            15
          );
          p.fill(70, 70, 120);
          p.ellipse(shoulderX, shoulderY, 40, 40); // Joint 1 Base

          // --- 2. 로봇팔 (순방향 기구학 및 회전) ---

          // 1. Joint 1 (어깨)
          p.push();
          p.translate(shoulderX, shoulderY);
          p.rotate(-J1_rad); // CCW 회전

          // 상박 (UpperArm.png 대체) 그리기
          const upperArmLength = link1Wheelbase;
          p.fill(50, 150, 50); // 녹색 상박 (임시)
          p.rectMode(p.CORNER);
          // 상박 링크는 (0, 0) 즉 Joint 1에서 시작하여 오른쪽으로 뻗습니다.
          p.rect(0, -linkWidth / 2, upperArmLength, linkWidth, 10);

          // Joint 2 (팔꿈치) 위치 계산 (상박의 끝)
          const elbowX = upperArmLength;
          const elbowY = 0;

          // 2. Joint 2 (팔꿈치)
          p.push();
          p.translate(elbowX, elbowY); // 팔꿈치 위치로 이동
          p.rotate(-J2_rad); // J1에 대한 상대적인 CCW 회전

          // 하박 (ForeArm.png 대체) 그리기
          const foreArmLength = link2Wheelbase;
          p.fill(200, 50, 50); // 빨간색 하박 (임시)
          p.rect(0, -linkWidth / 2, foreArmLength, linkWidth, 10);

          // End-Effector (펜 끝)
          const endEffectorX_local = foreArmLength;
          const endEffectorY_local = 0;

          p.pop(); // Joint 2 회전/이동 복구

          // Joint 2 시각화
          p.fill(255, 100, 0); // 주황색 팔꿈치 관절
          p.ellipse(elbowX, elbowY, linkWidth + 10, linkWidth + 10);

          p.pop(); // Joint 1 회전/이동 복구

          // --- 3. End-Effector 절대 좌표 계산 (Display용) ---

          // J1 및 J2 각도를 이용한 순방향 기구학 (Forward Kinematics, 어깨 기준 상대 좌표)
          const J2_abs_x_relative = upperArmLength * p.cos(-J1_rad);
          const J2_abs_y_relative = upperArmLength * p.sin(-J1_rad);

          const total_angle_rad = -(J1_rad + J2_rad);

          const EE_abs_x_relative =
            J2_abs_x_relative + foreArmLength * p.cos(total_angle_rad);
          const EE_abs_y_relative =
            J2_abs_y_relative + foreArmLength * p.sin(total_angle_rad);

          // End-Effector 팁 (현재 위치 시각화)
          p.fill(0);
          p.ellipse(
            shoulderX + EE_abs_x_relative,
            shoulderY + EE_abs_y_relative,
            15,
            15
          );

          // --- 4. 펜 궤적 관리 ---
          if (isPenDown) {
            // 5프레임마다 한 번씩 좌표를 저장하여 부드러움을 유지하고 성능을 확보
            if (p.frameCount % 5 === 0) {
              pathPoints.push({ x: EE_abs_x_relative, y: EE_abs_y_relative });
            }
          }

          // --- 5. 펜 궤적 그리기 ---
          if (pathPoints.length > 1) {
            p.push();
            // 궤적을 그릴 때 어깨 위치로 이동하여 저장된 상대 좌표를 사용
            p.translate(shoulderX, shoulderY);
            p.stroke(0); // 검정색
            p.strokeWeight(2 / canvasScale); // 줌 레벨에 따라 선 굵기 보정
            p.noFill();

            p.beginShape();
            for (let point of pathPoints) {
              p.vertex(point.x, point.y);
            }
            p.endShape();
            p.pop();
          }

          p.pop(); // 스케일 복구

          // End-Effector 좌표를 UI에 표시 (실제 좌표계 기준)
          document.getElementById("x_end_display").textContent =
            EE_abs_x_relative.toFixed(2);
          // p5.js의 Y축은 아래로 갈수록 증가하므로, 전통적인 좌표계를 위해 부호를 반전
          document.getElementById("y_end_display").textContent =
            (-EE_abs_y_relative).toFixed(2);
        };

        p.windowResized = function () {
          // 캔버스 크기 재설정
          const container = document.getElementById("p5-canvas");
          canvasWidth = container.clientWidth;
          canvasHeight = container.clientHeight;
          p.resizeCanvas(canvasWidth, canvasHeight);
          // ***********************************************
          // ** 어깨 기준점을 새로운 크기에 맞게 재설정 **
          // ***********************************************
          shoulderX = canvasWidth * 0.55; // X축 55% 지점
          shoulderY = canvasHeight * 0.8; // Y축 80% 지점
          // 펜 동선 파악을 위해 몸통부 위치를 조정했습니다.
        };
      }, "p5-canvas");

      // --- UI 상호 작용 로직 ---

      // HTML 요소를 가져오기
      const slider1 = document.getElementById("targetAngle1_slider");
      const input1 = document.getElementById("targetAngle1_input");
      const slider2 = document.getElementById("targetAngle2_slider");
      const input2 = document.getElementById("targetAngle2_input");
      const speedSlider = document.getElementById("angleSpeed_slider");
      const speedDisplay = document.getElementById("angleSpeed_display");
      const zoomSlider = document.getElementById("zoom_slider");
      const zoomDisplay = document.getElementById("zoom_display");

      // 펜 제어 요소
      const penToggle = document.getElementById("pen_toggle");
      const penStatus = document.getElementById("pen_status");
      const clearButton = document.getElementById("clear_path_button");

      // Joint 1 이벤트 리스너
      const updateJoint1 = (value) => {
        const numVal = parseInt(value);
        const clampedVal = Math.min(150, Math.max(0, numVal));
        slider1.value = clampedVal;
        input1.value = clampedVal;
        raccoon.moveByAngle(clampedVal, raccoon.targetAngleJoint2);
      };
      slider1.addEventListener("input", (e) => updateJoint1(e.target.value));
      input1.addEventListener("input", (e) => updateJoint1(e.target.value));

      // Joint 2 이벤트 리스너
      const updateJoint2 = (value) => {
        const numVal = parseInt(value);
        const clampedVal = Math.min(100, Math.max(-10, numVal));
        slider2.value = clampedVal;
        input2.value = clampedVal;
        raccoon.moveByAngle(raccoon.targetAngleJoint1, clampedVal);
      };
      slider2.addEventListener("input", (e) => updateJoint2(e.target.value));
      input2.addEventListener("input", (e) => updateJoint2(e.target.value));

      // 속도 슬라이더 이벤트 리스너
      speedSlider.addEventListener("input", (e) => {
        const speed = parseInt(e.target.value);
        speedDisplay.textContent = speed;
        raccoon.angleSpeed = speed;
      });

      // 줌 슬라이더 이벤트 리스너
      zoomSlider.addEventListener("input", (e) => {
        const scaleFactor = parseInt(e.target.value) / 100.0;
        zoomDisplay.textContent = `${scaleFactor.toFixed(1)}x`;
        canvasScale = scaleFactor;
      });

      // 펜 토글 이벤트 리스너
      penToggle.addEventListener("change", (e) => {
        isPenDown = e.target.checked;
        if (isPenDown) {
          penStatus.textContent = "펜 켜짐 (ON)";
          penStatus.classList.add("text-green-700");
          penStatus.classList.remove("text-gray-700");
        } else {
          penStatus.textContent = "펜 꺼짐 (OFF)";
          penStatus.classList.add("text-gray-700");
          penStatus.classList.remove("text-green-700");
        }
      });

      // 궤적 지우기 버튼 이벤트 리스너
      clearButton.addEventListener("click", () => {
        pathPoints = []; // 궤적 배열 초기화
      }); -->
    </script>
  </body>
</html>
